package Lexy::Playlist;

use Moose;
use namespace::autoclean;

use Carp qw/croak/;

use Lexy::Common;
use Lexy::Playlist::Item::FeedItem;
use Lexy::Playlist::Item::Share;
use Lexy::Playlist::Item::ShareIntro;
use Lexy::Playlist::Item::Recommendation;
use Lexy::Playlist::Item::DirectConnect;
use Lexy::Playlist::Item::Related;
use Lexy::Playlist::Item::Comment;
use Lexy::Playlist::Item::QuikHit;

use DBIx::Class::ResultClass::HashRefInflator;

has 'caller' => (
    is => 'rw',
    isa => 'Lexy::Schema::LexyDB::Result::Caller',
    required => 1,
);

# current position
has 'i' => (
    is => 'rw',
    isa => 'Int',
    default => 0,
);

has 'itemsref' => (
    is => 'rw',
    isa => 'ArrayRef',
    default => sub { [] },
);

has 'dbh' => (
    is => 'rw',
);

has 'partner' => (
    is => 'rw',
    isa => 'Maybe[Lexy::Schema::LexyDB::Result::Partner]',
);

has 'loaded' => (
    is => 'rw',
    isa => 'Bool',
    clearer => 'clear_loaded',
);

has 'loaded_recommendations' => (
    is => 'rw',
    isa => 'Bool',
);


######################################

# count how many of each type of item there are
sub share_count {
    my ($self) = @_;
    return scalar (grep { $_->is_share } @{$self->itemsref});
}
sub subscribed_item_count {
    my ($self) = @_;
    return scalar (grep { $_->is_feed_item } @{$self->itemsref});
}
sub recommendation_count {
    my ($self) = @_;
    return scalar (grep { $_->is_recommendation } @{$self->itemsref});
}

sub load_recommendations {
    my ($self) = @_;
    
    return if $self->loaded_recommendations;
    
    my $items = $self->all_items;
    push @$items, @{$self->all_recommendations};
    
    $self->loaded_recommendations(1);
}

# returns arrayref of Lexy::Playlist::Item instances of shares, rtqs, feeds, recommendations
*load_items = \&all_items;
sub all_items {
    my ($self) = @_;
    
    return $self->itemsref if $self->loaded;

    my @items;
    push @items, @{$self->all_partner_items};
    push @items, @{$self->all_shares_and_share_intros};
    push @items, @{$self->all_subscribed_items};

    $self->itemsref(\@items);

    my $first_item = $items[0];
    if ($first_item && $first_item->content && $self->caller->contentmark) {
        my $content_id = int($self->caller->contentmark / 10000);
        my $offset = $self->caller->contentmark % 10000;
        print STDERR "Recalling Perfect Memory:  content $content_id, offset $offset\n";
        if ($offset && $first_item->content->id == $content_id) {
            #$first_item->content->get_from_storage();
            $first_item->content->offset_in_seconds($offset);
            $first_item->perfect_memory(1);
        }
    }
    
    $self->loaded(1);
    
    return \@items;
}

=head2

L<insert_items(@items)>:  insert @items after the current position in the playlist

=cut
sub insert_items {
    my ($self, @items) = @_;
    
    my $items = $self->itemsref || [];
    my $i = $self->i;
        
    splice(@$items, $i, 0, @items);
}

# expects feeditem
sub insert_quikhit {
    my ($self, $quikhit_item) = @_;
    
    my $playlistitem = Lexy::Playlist::Item::QuikHit->new(
        playlist => $self,
        content => $quikhit_item->content,
        feed_item => $quikhit_item,
    );
    $self->insert_items($playlistitem);
    return $playlistitem;
}

=head2

L<remove_related_items>: delete all related items from the playlist, mantaining current position

=cut
sub remove_related_items {
    my ($self) = @_;
    
    my $items = $self->itemsref || [];
    my $i = $self->i;
    
    # count how many related lexys we've heard so far
    my $heard_related_count = grep { $_->is_related } @{$items}[0..$i];
    
    my @new_items = grep { ! $_->is_related } @$items;
    $self->itemsref(\@new_items);

    $i -= $heard_related_count;
    $i = 0 if $i < 0;
    $self->i($i);
}

=head2

L<get_next_item()>:  an iterator that returns the next item

Call like this:

while (defined (my $item = $playlist->get_next_item())) {
    ... do something with $item
}

=cut
sub get_next_item {
    my ($self) = @_;
    
    $self->go_forward(1);
    return $self->get_current_item;
}

=head2 get_previous_item

Return the previous item, but without affecting the internal counter
used by the get_next_item iterator.

=cut

sub get_previous_item {
    my ($self) = @_;

    $self->load_items;

    my $last_idx = $self->i - 1;
    $last_idx = 0 if $last_idx < 0;

    return $self->all_items->[ $last_idx ];
}

sub item_count {
    my ($self) = @_;
    
    return scalar @{ $self->all_items };
}

sub get_current_item {
    my ($self) = @_;
    
    if ($self->i < @{ $self->all_items }) {
        return $self->all_items->[ $self->i ];
    } else {
        if (! $self->loaded_recommendations) {
            $self->load_recommendations;
            
            if ($self->i < @{ $self->all_items }) {
                return $self->all_items->[ $self->i ];
            }
        }
        
        return;
    }
}

=head2 go_back

L<go_back($n)>: go back in the iteration.  Call this to decrement the index on
$self->itemsref.  *Then* call L<get_next_item()> to get the previous item.

For instance, to play the currrent item again, you would do:

=over 4
$playlist->go_back(1);
my $same_item = $playlist->get_next_item();
=back

To play the last item before this one, you would do:

=over 4
$playlist->go_back(2);
my $previous_item = $playlist->get_next_item();
=back

If you try to go back beyond the beginning of the playlist (i.e. if you pass a
number that is too big), you just get the first item.

Dies with a string exception if you try to go back 0 items (or undef items), since
that doesn't make sense.

See also:  L<get_next_item()>.

=cut
sub go_back {
    my ($self, $n) = @_;
    
    $self->load_items;

    if (!defined $n) {
        croak "go_back() requires an integer argument.  Got undef";
    }
    if ($n == 0) {
        croak "Going back 0 items is meaningless.  Error";
    }
    elsif (($self->i - $n) < 0) {
        $self->i(0);
    }
    else {
        $self->i($self->i - $n);
        return;
    }
}

sub go_forward {
    my ($self, $n) = @_;
    
    $self->load_items;
    
    if (!defined $n) {
        croak "go_back() requires an integer argument.  Got undef";
    }
    
    if ($n == 0) {
        croak "Going back 0 items is meaningless.  Error";
    }
    
    $self->i($self->i + $n); # It's all right to increment i past the end of items, because get_next_item checks
                             # to see if i > length and returns undef if so.
    
    # if we're at the end, load recommendations
    if (! $self->loaded_recommendations && ! $self->get_current_item) {
        $self->load_recommendations;
    }
    
    return;
}

# are we at the first item in the playlist?
sub at_start {
    my ($self) = @_;
    
    return ! $self->i;
}

# sub insert_jumpfile {
#     my ($self, $jumpfile) = @_;
#     if (!defined $self->{i}) {
#         croak 'invalid call to Lexy::Playlist->insert_jumpfile:  it was called before any files were played,';
#     } else {
#         my @items_copy = @{ $self->{itemsref} };
#         splice @items_copy
#     }
# }

=head2 all_shares_and_share_intros

L<all_shares_and_share_intros()> - returns a reference to a flat list of shares and
share intros.  Not all shares have intros, so the list might look like this:

[
    $intro_1,
    $share_1,
    $share_2,
    $share_3,
    $intro_4,
    $share_4,
]

Each share is of type Lexy::Playlist::Item::Share; each share intro is of type
Lexy::Item::ShareIntro.
=cut

sub all_shares_and_share_intros {
    my ($self) = @_;

    my @shares = $self->rs('Audioshare')->search({
	    touser     =>  $self->caller->id,
	    dateheard  =>  undef,
    }, {
        prefetch => [qw( content )],
        order_by => ['dateshared DESC'],
    });
    
    # construct share playlist items
    my @items;

    foreach my $share (@shares) {
        next unless $share->content;

        my $share_item = Lexy::Playlist::Item::Share->new(
          playlist => $self,
          content  => $share->content,
          share    => $share,
        );

        if (defined $share->messagecontent) {
          my $share_intro = Lexy::Playlist::Item::ShareIntro->new(
              playlist => $self,
              share    => $share,
              content  => $share->messagecontent,
          );
          push @items, $share_intro;
        }
        push @items, $share_item;
    }
    

    return \@items;
}

# returns arrayref of pending recommendations
# STUB
sub all_recommendations {
    my ($self) = @_;
    
    my @recs;
    my @rec_ids;
    my $recs_rs;
    
    my $RECOMMENDATION_LIMIT = 5;
    
    # get recs from bucketTags
    # go through each bucket
    my @buckets = $self->rs('Bucket')->search({}, { order_by => ['position'] })->all;
    foreach my $bucket (@buckets) {

        # pick random tag
        my $bucket_tag = $bucket->buckettags->search({}, {
            order_by => [\'RAND()'],
        })->first or next;
        
        # pick random feed from tag
        my $feed_id = $self->rs('Feedtag')->search({
            tag => $bucket_tag->tag->id,
        }, {
            order_by => [\'RAND()'],
        })->get_column('audiofeed')->first;
    
        push @rec_ids, $feed_id if $feed_id;
    
        last if @rec_ids > $RECOMMENDATION_LIMIT;
    }

    if (@rec_ids < $RECOMMENDATION_LIMIT &&
        $self->caller->visits < 10 && ( $self->caller->source || $self->partner )) {
            
        # caller hasn't called much, give them content that is related to however they found lexy
        
        # get partner recs
        # use DC partner id if available, otherwise caller source, otherwise 1 (lexy)
        my $source;
        $source = $self->partner->id if $self->partner;
        $source ||= $self->caller->source || 1;
        my @feed_ids = $self->rs('Partnerrecommendation')->search({
            partner => $source,
        })->get_column('audiofeed')->all;
        
        push @rec_ids, @feed_ids;
    }
    
    # fallback to recommendable feeds if nothing found
    if (! @rec_ids) {
        $recs_rs = $self->rs('Audiofeed')->search({
            recommendable => 1,
        }, {
            order_by => [\'RAND()'],
        });
    } else {
        $recs_rs = $self->rs('Audiofeed')->search({
            'me.id' => \@rec_ids,
        });
    }
    
    my @feeds = $recs_rs->never_subscribed_by($self->caller)->all;
    # map id => feed row
    my $feed_map = {
        map { ($_->id => $_) } @feeds
    };

    my @items;
    
    # preload content
    my @content_ids = grep { $_ } map { $_->lastcontent } @feeds;
    my @content = $self->rs('Content')->search({
        id => \@content_ids,
    });
    # map id => content row
    my $content_map = {
        map { ($_->id => $_) } @content
    };
    
    foreach my $feed_id (@rec_ids) {
        my $f = $feed_map->{$feed_id} or next; # might be missing if already subscribed
        
        my $content = $content_map->{$f->lastcontent};
        
        my %rec = (
            playlist => $self,
        );
        
        unless ($content) {
            my $feed_item = $f->latest_item or next;
            $content = $feed_item->content or next;
            $rec{feed_item} = $feed_item;
        }
        
        $rec{content} = $content;
        
        push @items, Lexy::Playlist::Item::Recommendation->new(%rec);
    }
    
    return \@items;
}

# returns arrayref of feeds for a partner directconnect #
sub all_partner_items {
    my ($self) = @_;
    return [] unless $self->partner;
    
    # get all feeds associated with this partner
    my @feeds = $self->rs('Audiofeed')->search({
        'me.partner'   => $self->partner->id,
    })->all;
    
    my @items = map { $_->latest_item } @feeds;
    return [ map {
        Lexy::Playlist::Item::DirectConnect->new(
            content   => $_->content,
            playlist  => $self,
            feed_item => $_,
        );
    } @items ];
}


# returns arrayref of all feeditems the caller has subscriptions to
sub all_subscribed_items {
    my ($self) = @_;

    my $dbh = $self->dbh || Lexy::Common::get_db_connection();
    $dbh->{RaiseError} = 1;
    $self->dbh($dbh);
    
    my @all_items;
    
    my $sth = $dbh->prepare(q{
        select
            subscription.id,
            subscription.audioFeed,
            audioFeed.lastContent

		from subscription,audioFeed

		where caller=?
        
        and audioFeed.lastContent != 0
		and subscription.audioFeed = audioFeed.id
		and ! subscription.unsubscribedFlag
		and ! heardLastContent

		group by audioFeed

		order by heardLastContent desc, (rtq*audioFeed.lastUpdate) desc, subscription.id asc
    });
    $sth->{RaiseError} = 1;
    
    print "\n\n\nyoyo\n\n\n";

    if ($sth->execute($self->caller->id)) {
        while (my ($subscription_id, $feed_id, $last_content_id) = $sth->fetchrow_array) {
<<<<<<< .mine
            print "$subscription_id, $feed_id, $last_content_id\n\n\n";
=======
            next unless $last_content_id;

>>>>>>> .r389
            # skip dupes (from directconnect)
            next if grep { $feed_id == $_->feed->id } @{ $self->itemsref };
            
            my $playlist_item = Lexy::Playlist::Item::FeedItem->new(
                content_id      => $last_content_id,
                subscription_id => $subscription_id,
                playlist        => $self,
            ); 

            push @all_items, $playlist_item;
        }
    } else {
        print STDERR "Failed to get playlist: " . $sth->errstr;
    }

    return \@all_items;
}

# get resultset (using caller's result_source)
sub rs {
    my ($self, $class) = @_;
    
    return $self->caller->result_source->schema->resultset($class);
}

__PACKAGE__->meta->make_immutable;
