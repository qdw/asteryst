package Lexy::AGI;

use Config::JFDI;
use Data::Dump 'pp'; # used experimentally, in Lexy::AGI->debug.  Nicer formatting than Data::Dumper?
use Data::Dumper;
use Devel::StackTrace;
use Exception::Class;
use Lexy::AGI::Session;
use Carp qw/croak/;

use Moose;
    extends 'Asterisk::FastAGI';

use Lexy::AGI::Controller::Comments;
use Lexy::AGI::Controller::Prompt;
use Lexy::AGI::Controller::DirectConnect;
use Lexy::AGI::Controller::Entry;

use Lexy::ContentFetcher;

has 'session' => (
    is => 'rw',
    isa => 'Maybe[Lexy::AGI::Session]',
    handles => [qw/context/],
);
has 'caller' => (
    is => 'rw',
);
has 'direct_connect' => (
    is => 'rw',
);
has 'dnid' => (
    is => 'rw',
);
has 'detached' => (
    is => 'rw',
    default => 0,
);
has 'fatal_error' => (
    is => 'rw',
    default => 0,
);
has 'stash' => (
    is => 'rw',
    isa => 'HashRef',
);
has 'schema' => (
    is => 'rw',
);
has '_dbh' => (
    is => 'rw',
);
has 'speech_engine_loaded' => (
    is => 'rw',
);
has 'loaded_controllers' => (
    is => 'rw',
    isa => 'HashRef',
);
has 'voice_session' => (
    is => 'rw',
    isa => 'Maybe[Lexy::Schema::LexyDB::Result::Voicesession]',
);
has 'hungup' => (
    is => 'rw',
    isa => 'Bool',
);
has 'loaded_grammars' => (   # stack of currently loaded grammars
    is => 'rw',
    isa => 'ArrayRef',
    default => sub { [] },
    lazy => 1,
);

use FindBin;
use lib "$FindBin::Bin/../lexy2perl/lib";
use lib "$FindBin::Bin/../lexy2perl/lexy3/lib";

use Lexy::Util;
use Lexy::Schema::LexyDB;
use Lexy::Content;
use Lexy::Common qw//;

# load controllers
use Class::Autouse;
Class::Autouse->load_recursive("Lexy::AGI::Controller");
use File::Basename qw(dirname);

use Lexy::AGI::Events;

# default Net::Server config options
sub default_values {
    return {
        log_level => 3,
        log_file  => '/var/lexy-inst/',
    };
}

# returns if loading grammar was successful
sub push_grammar {
    my ($self, $grammar) = @_;
    
    push @{$self->loaded_grammars}, $grammar;
    return $self->activate_grammar($grammar);
}

# returns grammar popped off the stack
sub pop_grammar {
    my ($self) = @_;
    
    my $grammar = pop @{$self->loaded_grammars};
    return undef unless $grammar;
    
    $self->deactivate_grammar($grammar);
    return $grammar;
}

sub activate_grammar {
    my ($self, $grammar_name) = @_;

    croak "No grammar specified to activate" unless $grammar_name;

    my $res = $self->agi->exec('SpeechActivateGrammar', $grammar_name);
    if (defined $res && $res == 0) {
        $self->debug("GRAMMAR Activated grammar $grammar_name");
        return 1;
    } else {
        $res = 'undef' unless defined $res;
        $self->debug("GRAMMAR Failed to activate grammar $grammar_name, res=$res");
        return 0;
    }
}

sub deactivate_grammar {
    my ($self, $grammar_name) = @_;

    croak "No grammar specified to deactivate" unless $grammar_name;

    my $res = $self->agi->exec('SpeechDeactivateGrammar', $grammar_name);
    if (defined $res && $res == 0) {
        $self->debug("GRAMMAR Deactivated grammar $grammar_name");
        return 1;
    } else {
        $res = 'undef' unless defined $res;
        $self->debug("GRAMMAR Failed to deactivate grammar $grammar_name, res=$res");
        return 0;
    }
}

=head2 config

Return the config, read in from lexy.yml.

$c->config();

This method uses memoization.  The first time it is invoked, it will read
lexy.yml; thereafter, it willreturn the cached copy.

It logs any errors to the Asterisk console, using $self->debug.

=cut
{
    my $config;
    sub config {
        my ($self) = @_;
        
        if (!defined $config) {
            my $own_path = (caller(0))[1];
            my $own_dir  = dirname $own_path;
            my $config_path = "$own_dir/../../lexy3";
            eval { $config = Config::JFDI->new(
                name => "Lexy",
                path => $config_path,
            )->load; };
            my $error_string = $@; # Config::YAML always dies with strings, not other things.
            if ($error_string) {
                $self->debug(qq(Could not load Lexy config file at $config_path.)
                          .  qq(  Error message from Config::JFDI->new:  '$error_string'));
            }
        }
        return $config;
    }
}

sub configure_hook {
    my ($self) = @_;

    # Preload config file, so that any errors (e.g. absence of the file) are evident up-front.
    $self->config;
    
    $self->check_config;
}

sub noop {
    my ($self) = @_;

    die q[found an attempt to call noop.  noop doesn't work, due to Asterisk::AGI problems, so we've disabled it];
}

sub check_config {
    my ($self) = @_;
    
    die "sound_file_extension missing" unless $self->config->{agi}{sound_file_extension};
    
    return 1;
}

sub setup {
    my ($self) = @_;
    
    # load speech engine
    my $res = $self->agi->exec('SpeechCreate');
    $res = 'undef' unless defined $res;
    
    my $engine_loaded = $self->var('SPEECH(status)');
    
    if ($engine_loaded) {
        $self->debug("Loaded speech engine, SPEECH(status)=$engine_loaded");
        my $busy_file = Lexy::AGI::Controller::Prompt->get_path($self, 'busy');
        $self->agi->exec('SpeechProcessingSound', $busy_file);
        $self->speech_engine_loaded(1);
    } else {
        $self->error("Could not load speech engine");
        $self->speech_engine_loaded(0);
    }

    $self->loaded_grammars([]);

    # preload some controllers
    $self->forward("/$_/LOAD_CONTROLLER") for qw/Comments Entry Playlist/;

    # reset state
    $self->hungup(0);
    $self->detached(0);
    $self->fatal_error(0);
    $self->direct_connect(undef);
    $self->caller(undef);
    $self->stash({});
    $self->voice_session(undef);

    $self->agi->setcallback(sub {
        my $code = shift;

        if ($code == -1) {
            # got hangup notification
            $self->log(1, "Caller hung up, detaching");
            $self->hungup(1);
            $self->detach;
        }
    });
}

sub cleanup {
    my ($self) = @_;

    # clear request variables
    $self->stash({});

    if (0) {
        # destroy controllers
        my $loaded_controllers = $self->loaded_controllers || {};
        foreach my $controller (values %$loaded_controllers) {
            $self->debug("Destroying controller $controller") if 0;
            $controller->UNLOAD_CONTROLLER($self);
        }
    
        $self->loaded_controllers({});
        # FIXME: if we clear the loaded controllers, we need to
        # destroy the singletons as well. how?
    }
    
    # unload speech engine
    if ($self->speech_engine_loaded) {
        $self->agi->exec('SpeechDestroy');
        $self->debug("Destroyed speech engine");
    }
}

# get an asterisk variable
sub var {
    my ($self, $var_name) = @_;
    return $self->agi->get_full_variable('${' . $var_name . '}');
}

# check if the current channel is active (i.e. not hung up)
sub channel_is_active {
    my ($self) = @_;
    return ! $self->hungup;
}

sub dbh {
    my ($self) = @_;
    
    return $self->_dbh if $self->_dbh;
    $self->_dbh(Lexy::Common::get_db_connection());
    return $self->_dbh;
}

# record an action in voiceActionTrackingLog
sub log_action {
    my ($self, $action_name, $fields) = @_;
    
    $fields ||= {};
	$fields->{caller}     ||= $self->caller->id if $self->caller;
	$fields->{session}    ||= $self->session->session_id if $self->session && $self->session->session_id;
	$fields->{actiontime} ||= \ 'NOW()';

    return $self->schema->resultset('VoiceactiontrackingLog2')->log_action($action_name, $fields);
}

# like log_action but populates audioFeed, audioFeedItem, content from a playlist item
sub log_action_for_playlist_item {
    my ($self, $action_name, $item, $fields) = @_;
    
    croak "No playlist item passed to log_action_for_playlist_item()"
        unless $item;
    
    $fields ||= {};
    
    $fields->{audiofeed}     ||= $item->feed->id      if $item->feed;
    $fields->{audiofeeditem} ||= $item->feed_item->id if $item->feed_item;
    $fields->{content}       ||= $item->content->id   if $item->content;
    
    $self->log_action($action_name, $fields);
}

sub dump {
    my ($self, $obj, $name) = @_;
    my $msg = Data::Dumper->Dump([$obj], [$name]);
    $self->debug($msg);
}

sub _print {
    my ($self, $string) = @_;
    $self->log(3, "$string");
    return;
}

sub debug {
    my ($self, @msg) = @_;
    
    my $i = 1;
    for my $element (@msg) {
        if (ref $element) {
            # Suppress for now--we don't want big data dumps.
            #$self->_print(pp($element));

            # This will result in refs being printed as HASH($mem_addr)
            # or the like
            $self->_print($element);
        }
        else {
            $self->_print($element);
        }
        # Print a space before the next word...
        $self->_print(q[ ])
            # ... unless we've reached the end of the array.
            unless $i == @msg;
        $i++;
    }

    return;
}

sub error {
    my ($self, @msg) = @_;
    
    my ($package, $filename, $line) = caller;
    $self->log(0, "ERROR ($package, $filename, $line): @msg");
    return;
}

sub detach {
    my ($self) = @_;
    $self->detached(1);
    return;
}

# print fatal error (should log in db or something too)
# don't do any more forwards, play oops sound, hang up
sub fatal_detach {
    my ($self, $err) = @_;
    
    Carp::cluck("Got fatal error");
    
    $self->forward('/Prompt/fatal_error');
    $self->error("[FATAL] $err");
    $self->detach();
    return 0;
}

sub prompt {
    my ($c, $prompt, $text) = @_;
    $c->forward("/Prompt/play", $prompt, $text);
}

sub earcon {
    my ($c, $earcon) = @_;
    $c->forward("/Prompt/earcon", $earcon);
}

# earcon to indicate we are busy doing something
sub busy {
    my ($c, $earcon) = @_;
    $c->forward("/Prompt/play_busy");
}

sub background {
    my ($c, $prompt) = @_;
    $c->forward("/Prompt/background", $prompt);
}

sub fetch_content_cached {
    my ($self, $content) = @_;
    
    if ($self->config->{agi}{use_local_content}) {
        return Lexy::Content::get_wrapped_slin_filename($content->id);
    }
    
    # this needs to move to the AGI
    my $expire = $self->config->{agi}{content_cache_expires} || 3600 * 24;
    my$file_extension = $self->config->{agi}{sound_file_extension};
    
    $self->busy;
    $self->log(3, "Fetching content " . $content->id);
    
    # call AGI
    $self->agi->exec("AGI", "lexy_fetch_content.pl," . $content->id);
    my $success = $self->var('content_fetch_success');
    my $path = $self->var('content_fetch_path');
    
    if (! $success) {
        my $err = $self->var('content_fetch_error') || "unknown";
        $self->error("Failed to fetch content error: $err, content id=" . $content->id);
        return;
    } elsif (! $self->check_if_content_path_exists($path)) {
        $self->error("Fetched content but path $path doesn't exist, content id=" . $content->id);
        return;
    }
    
    return $path;
}

sub check_if_content_path_exists {
    my ($c, $path) = @_;

    return 1 unless $c->config->{agi}{'check_content_existance'};
    my $check_path = $path;

    # add extension if missing
    my $content_ext = $c->config->{agi}{sound_file_extension};
    $check_path .= '.' . $content_ext unless $check_path =~ /\.$content_ext$/i;

    return (-e $check_path && -s $check_path); # file must exist and have a non-zero size
}

sub prepare_request {
    my $self = shift;
    
    $self->setup;
    
    my $agi = $self->agi;
	
    $self->schema(Lexy::Schema::LexyDB->get_connection);

    my $info = $self->input;
    $self->log(4, "got AGI call with input: " . Dumper($self->input));
    my $caller_id_name = $self->input('calleridname') || '';
    my $caller_id_num  = Lexy::Util->sanitize_number($self->input('callerid')) || '';
    my $dest_num       = $self->input('dnid') || $self->input('extension') || '';
    my $session_id     = $self->input('uniqueid');

    # create a session for this call
    my $session = new Lexy::AGI::Session(
        session_id => $session_id,
        context    => 'begin',
        agi        => $self,
    );
    $self->session($session);
    
    $self->dnid($dest_num);
    
    $agi->answer();
    $agi->exec('wait', '1');

    unless ($caller_id_num) {
        # no callerID number
        $self->forward('/Prompt/no_caller_id');
        $self->debug("Got call with no callerID... bailing");
        $agi->hangup();
        return 0;
    }
    	
    $self->debug("Got call from $caller_id_name <$caller_id_num> to DID $dest_num");
	
    my $caller = $self->look_up_caller($caller_id_num);
    $self->caller($caller);
    $self->log(2, "Using caller record for $caller_id_num: id=" . $caller->id);
    
    $caller->increment_visit_count;
    
    # start voice_session
    my $vsession = $self->schema->resultset('Voicesession')->create({
        caller           => $caller->id,
        starttime        => \ 'NOW()',
        dialednumber     => $dest_num,
        gatewaysessionid => $session_id,
    });
    
    $self->voice_session($vsession);
	
    return 1;
}

sub look_up_caller {
    my ($self, $num) = @_;
    
	my $caller = $self->schema->resultset('Caller')->search({
	    -or => [
	        { phonenumber => $num },
	        { phone2      => $num },
	    ],
	})->single;
	
	if (! $caller) {
	    # virgin caller
	    $self->debug("Virgin caller, creating caller record for $num...");
	    $caller = $self->schema->resultset('Caller')->create({
	        phonenumber => $num,
	    });
	} else {
	    $self->debug("Existing caller record found...");
	}
	
	return $caller;
}

sub finalize_request {
    my ($self) = @_;

    $self->context('end');
    $self->cleanup;
    
    # finish session
    if ($self->voice_session) {
        my $session_update = {
            endtime => \ 'NOW()',
        };
        
        $self->voice_session->update($session_update);
    }
    $self->session(undef);
    
    $self->debug("Finished call, hanging up");
    $self->agi->hangup;
}

# overridden from Asterisk::FastAGI
sub _parse_request {
  my $self = shift;

  # Grab the method and optional path.
  my $req = $self->{server}{input}{request};
  unless ($req) {
      $self->debug("Did not get request string from AGI server");
      return;
  }

  my ($class, $method, $param_string) = $self->_parse_request_uri($req);

  my %params;

  if (defined $param_string) {
      my (@pairs) = split(/[&;]/,$param_string);
      foreach (@pairs) {
          my($p,$v) = split('=',$_,2);
          $params{$p} = $v;
      }
  }

  $self->{request}->{params} = \%params;
  $self->{request}->{uri} = $req;
  return;
}

# parse uri
sub _parse_request_uri {
    my ($self, $uri_in) = @_;
    
    # split up uri
     my($class, $method, $param_string) = $uri_in
         =~ m{ (?: agi://(?:[-\w.:]+) )?  # scheme, host, port
                / ([^/]*)?                # class
                / ([^?]*)?                # method
                 \?? (.*)                 # params
             }smxi;
                
    return ($class, $method, $param_string);
}

sub pre_server_close_hook {
    my ($self) = @_;

    $self->debug('pre_server_close hook called');
    return if ! $self->speech_engine_loaded;
    $self->agi->exec('SpeechDestroy');
    $self->speech_engine_loaded(0);
    return;
}

# overridden from Asterisk::FastAGI
sub dispatch_request {
    my $self = shift;

    my $uri = $self->{request}{uri};
    unless ($uri) {
        return $self->error("Got dispatch_request with no URI specified");
    }

    $self->log(2, "Dispatching request for $uri");

    unless ($self->prepare_request) {
        $self->error("prepare_request failed, exiting");
        return;
    }

    my $pretty_invocation = $uri . join (q{ }, %{$self->{request}->{params}});
    eval { $self->forward($uri, %{$self->{request}->{params}}); };

    if ($@) {
    	my $event = $@;

        $self->log(3, "Dispatch to $uri threw an event: $event");

    	if ($event->isa('Lexy::AGI::UserGaveCommand')) {
    	    $self->error("Uncaught user command from $pretty_invocation", $event->command, 'with score', $event->score);
    	} elsif ($event->isa('Lexy::AGI::SpeechEngineNotReady')) {
    	    $self->error($event->description . '.', "$pretty_invocation aborted");
    	} elsif ($event->isa('Lexy::AGI::SpeechBackgroundFailed')) {
    	    $self->error("SpeechBackground failed; $pretty_invocation aborted");
    	} else {
    	    my $error_message;
    	    if (ref $event) {
    		$error_message = Dumper($event);
    	    } else {
    		$error_message = $event;
    	    }
    	    $self->error("$pretty_invocation failed.  Error message:  $error_message");
    	}

    	# No good.  Devel::StackTrace doesn't let us peek into the eval.
    	#my $trace = Devel::StackTrace->new->as_string;
    	#$self->debug($trace);
    }

    $self->finalize_request;
}

=head2 forward

my @retvals;
eval { @retvals = $self->forward('/controller_name/method_name', $arg1, $arg2); }

or

my $retval;
eval { $retval = $self->forward('/controller_name/method_name', $arg1, $arg2); }

Executes a controller method; returns the retval of that method.  You
can do this in scalar or list context, and L<forward()> will do the right thing.

If the target method throws exceptions, L<forward()> will pass them along,
so you should always call L<forward()> in an eval if you wish to do error handling.  This is especially
important in Lexy::AGI-land because user input events are modeled as
exceptions.

Controller methods may themselves call L<forward()>.  For instance,
Lexy::AGI::Playlist->play might invoke Lexy::AGI::Comment->play under
certain conditions, like this:

=over 4
$c->forward('/Comment/play, @some_args);
=back

=cut
sub forward {
    my ($self, $path, @params) = @_;
    
    # don't do anything if "detached"
    return if $self->detached;

    my ($class, $method) = $self->_parse_request_uri($path);
    unless ($class && $method) {
        $self->fatal_detach("Failed to parse URI $path");
    }

    $self->debug("Forwarding to $path");

    unless ($self->loaded_controllers) {
        $self->loaded_controllers({});
    }

    # load controller singleton
    my $controller;
    if ($self->loaded_controllers->{$class}) {
        $controller = "Lexy::AGI::Controller::$class"->instance;
    } else {
        $controller = "Lexy::AGI::Controller::$class"->initialize({
            context => $self,
        });
            
        $self->loaded_controllers->{$class} = $controller;
    }

    return $controller->$method($self, @params);
}

# parse an incoming AGI request from asterisk
sub _agi_parse {
  my $self = shift;

  # Create an instance of our AGI interface
  $self->agi(Lexy::CoolAGI->new);

  # Parse the request.
  my %input = $self->agi->ReadParse();
  $self->{server}{input} = \%input;
}


# overloaded version of Asterisk::AGI, used for sending/receiving commands to asterisk
package Lexy::CoolAGI;

use parent 'Asterisk::AGI';
use autodie ':io';

sub _execcommand {
	my ($self, $command, $fh) = @_;

    my $oldfh;
    # since asterisk communication happens over STDOUT, we want 
    # to make extra-sure we aren't printing anything on STDOUT.
    my $unselect = sub {
        my $ret = shift;
        my $stderr = \*STDERR;
        select $stderr;
        return $ret;
    };

	$fh = \*STDOUT if (!$fh);

	$oldfh = select ((select ($fh), $| = 1)[0]);

	return $unselect->(-1) if (!defined($command));

	print STDERR "_execcommand: '$command'\n" if ($self->_debug>3);

	my $res = print $fh "$command\n";
	return $unselect->($res);
}

1;
